"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[93350],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>m});var a=n(96540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},g="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=d(e,["components","mdxType","originalType","parentName"]),g=l(n),p=i,m=g["".concat(s,".").concat(p)]||g[p]||c[p]||r;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=p;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d[g]="string"==typeof e?e:i,o[1]=d;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},99312:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var a=n(58168),i=(n(96540),n(15680));const r={title:"Audit data format definition and usage",sidebar_position:5},o=void 0,d={unversionedId:"development/binary_protocol/audit_msg",id:"development/binary_protocol/audit_msg",title:"Audit data format definition and usage",description:"Overview",source:"@site/docs/development/binary_protocol/audit_msg.md",sourceDirName:"development/binary_protocol",slug:"/development/binary_protocol/audit_msg",permalink:"/docs/next/development/binary_protocol/audit_msg",draft:!1,editUrl:"https://github.com/apache/inlong-website/edit/master/docs/development/binary_protocol/audit_msg.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Audit data format definition and usage",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"TubeMQ binary protocol",permalink:"/docs/next/development/binary_protocol/tubemq_binary"},next:{title:"Agent Plugin",permalink:"/docs/next/development/extension_agent/agent"}},s={},l=[{value:"Overview",id:"overview",level:2},{value:"Audit SDK raw data format",id:"audit-sdk-raw-data-format",level:2},{value:"Audit Header",id:"audit-header",level:4},{value:"Audit Body",id:"audit-body",level:4},{value:"AuditData data format",id:"auditdata-data-format",level:2},{value:"Audit data storage format",id:"audit-data-storage-format",level:2},{value:"ClickHouse table Schema",id:"clickhouse-table-schema",level:3},{value:"MySQL table Schema",id:"mysql-table-schema",level:3}],u={toc:l},g="wrapper";function c(e){let{components:t,...r}=e;return(0,i.yg)(g,(0,a.A)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,"In the InLong system architecture, modules such as the collection layer, aggregation layer, and sorting layer report\naudit data to the Audit system through the Audit SDK. The Audit Proxy component is responsible for receiving this data\nand converting it into the ",(0,i.yg)("inlineCode",{parentName:"p"},"AuditData")," format, which is then stored in the message body of the MQ message.\nNext, the Audit Store extracts this data from the MQ and persists it in storage systems such as ClickHouse. This article\nwill provide an in-depth analysis and explanation of the data protocol related to the Audit system."),(0,i.yg)("p",null,(0,i.yg)("img",{src:n(39230).A,width:"446",height:"62"})),(0,i.yg)("h2",{id:"audit-sdk-raw-data-format"},"Audit SDK raw data format"),(0,i.yg)("p",null,"The raw data of the Audit SDK is encapsulated using the Protobuf protocol, which includes information such as request\ntype, common data header, and data body. Here is a detailed description of the relevant protocol:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\n\npackage org.apache.inlong.audit.protocol;\n\nmessage BaseCommand {\n  enum Type {\n    PING = 0;\n    PONG = 1;\n    AUDIT_REQUEST = 2;\n    AUDIT_REPLY = 3;\n  }\n  Type type = 1;\n  AuditRequest audit_request = 2;\n  AuditReply audit_reply = 3;\n  Ping ping = 4;\n  Pong pong = 5;\n}\n\nmessage Ping {\n}\n\nmessage Pong {\n}\n\nmessage AuditRequest {\n  uint64 request_id = 1;\n  AuditMessageHeader msg_header = 2;\n  repeated AuditMessageBody msg_body = 3;\n}\n\nmessage AuditMessageHeader {\n  string ip = 1;\n  string docker_id = 2;\n  string thread_id = 3;\n  uint64 sdk_ts = 4;\n  uint64 packet_id = 5;\n}\n\nmessage AuditMessageBody {\n  uint64 log_ts = 1;\n  string inlong_group_id = 2;\n  string inlong_stream_id = 3;\n  string audit_id = 4;\n  uint64 count = 5;\n  uint64 size = 6;\n  int64  delay = 7;\n  string audit_tag = 8;\n  uint64 audit_version = 9;\n}\n\nmessage AuditReply {\n  enum RSP_CODE {\n    SUCCESS = 0;\n    FAILED = 1;\n    DISASTER = 2;\n  }\n  uint64 request_id = 1;\n  RSP_CODE rsp_code = 2;\n  string message = 3;\n}\n')),(0,i.yg)("h4",{id:"audit-header"},"Audit Header"),(0,i.yg)("p",null,"The header of the audit data contains the following machine metadata information: machine IP, container ID, thread ID,\ncurrent machine time, and data packet ID. Here is the specific protocol description:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-protobuf"},"message AuditMessageHeader {\n  string ip = 1;\n  string docker_id = 2;\n  string thread_id = 3;\n  uint64 sdk_ts = 4;\n  uint64 packet_id = 5;\n}\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"IP: Record the IP address of the machine generating or processing the data;"),(0,i.yg)("li",{parentName:"ul"},"Docker ID: Identify the container to which the data belongs;"),(0,i.yg)("li",{parentName:"ul"},"Thread ID: Identify the thread generating or processing the data;"),(0,i.yg)("li",{parentName:"ul"},"SdkTs: Record the machine timestamp of the data reported by the SDK;"),(0,i.yg)("li",{parentName:"ul"},"Packet ID: Used to identify each data packet;")),(0,i.yg)("p",null,"The purpose of these machine metadata information is to achieve deduplication of audit data and enable operational\nmonitoring. By recording and analyzing these information, it ensures the uniqueness of the data and facilitates\noperations monitoring and troubleshooting activities."),(0,i.yg)("h4",{id:"audit-body"},"Audit Body"),(0,i.yg)("p",null,"The subject of audit data includes the following information: data time, InLong GroupId, InLong StreamId, AuditId,\nAuditTag, Audit version, count, size, and transmission delay. Here is the specific protocol description:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-protobuf"},"message AuditMessageBody {\n  uint64 log_ts = 1;\n  string inlong_group_id = 2;\n  string inlong_stream_id = 3;\n  string audit_id = 4;\n  uint64 count = 5;\n  uint64 size = 6;\n  int64  delay = 7;\n  string audit_tag = 8;\n  uint64 audit_version = 9;\n}\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"LogTs: Record the timestamp of data generation or processing;"),(0,i.yg)("li",{parentName:"ul"},"InLong GroupId: Identify the InLong group to which the data belongs;"),(0,i.yg)("li",{parentName:"ul"},"InLong StreamId: Identify the InLong stream to which the data belongs;"),(0,i.yg)("li",{parentName:"ul"},"AuditId: Used to uniquely identify each audit record;"),(0,i.yg)("li",{parentName:"ul"},"AuditTag: Used to tag specific audit records;"),(0,i.yg)("li",{parentName:"ul"},"Audit Version: Record the version number of the audit record;"),(0,i.yg)("li",{parentName:"ul"},"Count: Record the number of entries included in the data;"),(0,i.yg)("li",{parentName:"ul"},"Size: Record the size of the data;"),(0,i.yg)("li",{parentName:"ul"},"Delay: Record the time taken for data transmission.")),(0,i.yg)("p",null,"The purpose of these audit information is for reconciliation to ensure the integrity and accuracy of the data. By\nperforming statistical analysis on this information, data validation, troubleshooting, and performance analysis\noperations can be achieved."),(0,i.yg)("h2",{id:"auditdata-data-format"},"AuditData data format"),(0,i.yg)("p",null,"The Audit Proxy is responsible for receiving Protobuf formatted data from the Audit SDK and parsing it. Once the parsing\nis complete, it assembles the Audit Header and Audit Body into a complete audit record, which is then written to a\nmessage queue ( MQ ). ",(0,i.yg)("inlineCode",{parentName:"p"},"AuditData")," represents the format of the assembled data, with the following specific details:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "ip": "127.0.0.1",\n  "dockerId": "1",\n  "threadId": "1",\n  "sdkTs": 1727600278000,\n  "packetId": 1,\n  "logTs": 1727600278000,\n  "inlongGroupId": "groupId",\n  "inlongStreamId": "streamId",\n  "auditId": "auditId",\n  "auditTag": "auditTag",\n  "count": 1,\n  "size": 1,\n  "delay": 1,\n  "auditVersion": 1\n}\n')),(0,i.yg)("h2",{id:"audit-data-storage-format"},"Audit data storage format"),(0,i.yg)("p",null,"The Audit Store consumes ",(0,i.yg)("inlineCode",{parentName:"p"},"AuditData")," audit data from the message queue ( MQ ), performs protocol parsing, and persists the\ndata into storage systems such as ClickHouse, MySQL, etc. The specific storage target schema is as follows:"),(0,i.yg)("h3",{id:"clickhouse-table-schema"},"ClickHouse table Schema"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-clickhouse"},"CREATE TABLE apache_inlong_audit.audit_data\n(\n    `log_ts`           DateTime COMMENT 'Log timestamp',\n    `audit_id`         String COMMENT 'Audit id',\n    `inlong_group_id`  String COMMENT 'The target inlong group id',\n    `inlong_stream_id` String COMMENT 'The target inlong stream id',\n    `audit_tag`        String COMMENT 'Audit tag',\n    `audit_version`    Int64 DEFAULT -1 COMMENT 'Audit version',\n    `ip`               String COMMENT 'Client IP',\n    `docker_id`        String COMMENT 'Client docker id',\n    `thread_id`        String COMMENT 'Client thread id',\n    `sdk_ts`           DateTime COMMENT 'SDK timestamp',\n    `packet_id`        Int64 COMMENT 'Packet id',\n    `count`            Int64 COMMENT 'Message count',\n    `size`             Int64 COMMENT 'Message size',\n    `delay`            Int64 COMMENT 'Message delay',\n    `update_time`      DateTime COMMENT 'Update time'\n)\n    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{uuid}/{shard}', '{replica}')\n        PARTITION BY toDate(log_ts)\n        ORDER BY (log_ts, audit_id, inlong_group_id, inlong_stream_id, audit_tag, audit_version, ip)\n        TTL toDateTime(log_ts) + toIntervalDay(8)\n        SETTINGS index_granularity = 8192\n")),(0,i.yg)("p",null,"As described above, the table uses the ReplicatedMergeTree storage engine to achieve distributed storage and high\navailability. The data will be partitioned based on the log_ts column and stored and managed in the order of ( log_ts,\naudit_id, inlong_group_id, inlong_stream_id, audit_tag, audit_version, ip ) to optimize query performance."),(0,i.yg)("h3",{id:"mysql-table-schema"},"MySQL table Schema"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-mysql"},"CREATE TABLE IF NOT EXISTS `audit_data`\n(\n    `id`               int(32)      NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT 'Incremental primary key',\n    `ip`               varchar(32)  NOT NULL DEFAULT '' COMMENT 'Client IP',\n    `docker_id`        varchar(100) NOT NULL DEFAULT '' COMMENT 'Client docker id',\n    `thread_id`        varchar(50)  NOT NULL DEFAULT '' COMMENT 'Client thread id',\n    `sdk_ts`           TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'SDK timestamp',\n    `packet_id`        BIGINT       NOT NULL DEFAULT '0' COMMENT 'Packet id',\n    `log_ts`           TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Log timestamp',\n    `inlong_group_id`  varchar(100) NOT NULL DEFAULT '' COMMENT 'The target inlong group id',\n    `inlong_stream_id` varchar(100) NOT NULL DEFAULT '' COMMENT 'The target inlong stream id',\n    `audit_id`         varchar(100) NOT NULL DEFAULT '' COMMENT 'Audit id',\n    `audit_tag`        varchar(100)          DEFAULT '' COMMENT 'Audit tag',\n    `audit_version`    BIGINT                DEFAULT -1 COMMENT 'Audit version',\n    `count`            BIGINT       NOT NULL DEFAULT '0' COMMENT 'Message count',\n    `size`             BIGINT       NOT NULL DEFAULT '0' COMMENT 'Message size',\n    `delay`            BIGINT       NOT NULL DEFAULT '0' COMMENT 'Message delay count',\n    `update_time`      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'Update time',\n    INDEX group_stream_audit_id (`inlong_group_id`, `inlong_stream_id`, `audit_id`, `log_ts`)\n) ENGINE = InnoDB\n  DEFAULT CHARSET = UTF8 COMMENT ='Inlong audit data table';\n")),(0,i.yg)("p",null,'As described above, the table uses the InnoDB storage engine to ensure data consistency. Additionally, an index\nnamed "group_stream_audit_id" has been created using the INDEX clause, which covers the columns inlong_group_id,\ninlong_stream_id, audit_id, and log_ts. This index creation helps improve query efficiency, especially when filtering\nand sorting based on these columns.'))}c.isMDXComponent=!0},39230:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/audit-fd6f6b03494c8bd04d347788f467e7ca.png"}}]);