---
title: Function Specification
sidebar_position: 3
---

# Arithmetic
| Function | Description | Example |
| ------ | ------ | ------ |
| abs(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the absolute value of 'numeric'.<br/> | abs(2) = 2<br/>abs(-4.25) = 4.25<br/> |
| acos(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the arc cosine of 'numeric'.<br/> | acos(1) = 0.0<br/>acos(0) = 1.5707963267948966<br/>acos(-1) = 3.141592653589793<br/> |
| acosd(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the arc cosine of 'numeric' in units of degrees.<br/> | acosd(1) = 0.0<br/>acosd(0) = 90.0<br/>acosd(-1) = 180.0<br/> |
| asin(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the arc sine of 'numeric' in units of degrees.<br/> | asin(0.5) = 0.5235987755982989<br/>asin(0) = 0.0<br/>asin(-0.5) = -0.5235987755982989<br/> |
| asind(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the arc sine of 'numeric' in units of degrees.<br/> | asind(0.5) = 30.000000000000004<br/>asind(0) = 0.0<br/>asind(-0.5) = -30.000000000000004<br/> |
| atan(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the arc tangent of 'numeric'.<br/> | atan(1) = 0.7853981633974483<br/>atan(0) = 0.0<br/>atan(-1) = -0.7853981633974483<br/> |
| atan2(Numeric numeric)<br/> | Return "" if 'numericx' or 'numericy' is NULL;<br/>Return the arc tangent of a coordinate ('numericx', 'numericy').<br/> | atan2(1, 1) = 0.7853981633974483<br/>atan2(1, 0) = 1.5707963267948966<br/>atan2(0, -1) = 3.141592653589793<br/> |
| atan2d(Numeric numericx, Numeric numericy)<br/> | - Return "" if 'numericx' or 'numericy' is NULL;<br/>- Return inverse tangent of 'numericy'/'numericx', result in degrees.<br/> | atan2d(1, 1) = 45.0<br/>atan2d(1, 0) = 90.0<br/>atan2d(0, -1) = 180.0<br/> |
| atand(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the arc tangent of 'numeric' in units of degrees.<br/> | atand(1) = 45.0<br/>atand(0) = 0.0<br/>atand(-1) = -45.0<br/> |
| bin(Integer integer)<br/> | - Return "" if 'integer' is NULL;<br/>- Return a string representation of 'integer' in binary format.<br/> | bin(4) = 100<br/> |
| cbrt(Numeric numeric)<br/> | - Return NULL if 'numeric' is NULL;<br/>- Return cube root.<br/> | cbrt(5) = 1.7099759466766968<br/>cbrt(27) = 3.0<br/> |
| ceil(Numeric numeric)<br/> | - Return NULL if 'numeric' is NULL;<br/>- Return the smallest number that is greater than or equal to 'numeric'.<br/> | ceil(-5.67) = -5.0<br/>ceil(1.23) = 2.0<br/> |
| chr(Integer integer)<br/> | - Return NULL if 'integer' is NULL;<br/>- Return the ASCII character having the binary equivalent to 'integer'.<br/> | chr(97) = "a"<br/>chr(353) = "a"<br/> |
| cos(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the cosine of 'numeric'.<br/> | cos(0) = 1.0<br/> |
| cosd(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the cosine of 'numeric' in units of degrees.<br/> | cosd(15) = 0.9659258262890683<br/> |
| cosh(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the hyperbolic cosine of 'numeric'.<br/> | cosh(1) = 1.543080634815244<br/>cosh(0) = 1.0<br/>cosh(-1) = 1.543080634815244<br/> |
| cot(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the cotangent of the 'numeric' (in radians).<br/> | cot(1) = 0.6420926159343306<br/>cot(0.5) = 1.830487721712452<br/>cot(-1) = -0.6420926159343306<br/> |
| cotd(Numeric numeric)<br/> | - Return "" if numeric is NULL;<br/>- Return the cotangent of numeric in units of degrees.<br/> | cotd(0) = ""<br/>cotd(45) = 1.0000000000000002<br/>cotd(-1) = -57.28996163075943<br/> |
| e()<br/> | - Return the mathematical constant.<br/> | e() = 2.718281828459045<br/> |
| erf(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the error function value of the input value.<br/> | erf(3) = 0.9999779095030014<br/> |
| erfc(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return complementary error (1 - erf('numeric'), without loss of precision for large inputs).<br/> | erfc(1) = 0.15729920705028488<br/> |
| exp(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return e raised to the power of 'numeric'.<br/> | exp(2) = 7.38905609893065<br/> |
| factorial(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the factorial of a non-negative.<br/> | factorial(5) = 120<br/>factorial(0) = 1<br/> |
| fibonacci(Numeric numeric)<br/> | - Return NULL if 'numeric' is NULL;<br/>- Returns the nth Fibonacci number<br/> | fibonacci(0) = 0<br/>fibonacci(1) = 1<br/>fibonacci(2) = 1<br/>fibonacci(3) = 2<br/>fibonacci(4) = 3<br/> |
| floor(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the largest number that is less than or equal to 'numeric'.<br/> | floor(1.23) = 1.0<br/>floor(-5.67) = -6.0<br/> |
| gcd(Numeric numeric1,Numeric numeric2)<br/> | - Return "" if any parameter is NULL;<br/>- Return 0 if both inputs are zero;<br/>- Return greatest common divisor (the largest positive number that divides both inputs with no remainder).<br/> | gcd(3.141,3.846) = 0.003<br/> |
| greatest(Numeric value1 [,Numeric value2,...])<br/> | - Return "" if any parameter is NULL;<br/>- Return the greatest value of the list of arguments.<br/> | greatest(3.141592653589793, 3, greatest(4, 1)) = 4<br/> |
| hex(String dataStr)<br/> | - Return "" if dataStr is NULL;<br/>- Return the string obtained by converting the dataStr to hexadecimal if 'dataStr' can be parsed into numeric;<br/>- Return the string obtained by converting the ASCII code corresponding to each character to hexadecimal otherwise.<br/> | hex(1007) = "3EF"<br/>hex('abc') = "616263"<br/> |
| lcm(Numeric numeric1,Numeric numeric2)<br/> | - Return "" if any parameter is NULL;<br/>- Return 0 if either input is zero;<br/>- Return least common multiple (the smallest strictly positive number that is an integral multiple of both inputs).<br/> | lcm(6,3) = 6<br/>lcm(3.141,3.846) = 4026.762<br/> |
| least(Numeric value1 [, Numeric value2, ...])<br/> | - Return "" if any parameter is NULL;<br/>- Return the least value of the list of arguments.<br/> | least(3.14, least(7, 2, 1)) = 1<br/> |
| ln(Numeric numeric)<br/> | - Return "" if numeric is NULL;<br/>- Return the natural logarithm (base e) of numeric.<br/> | ln(10) = 2.302585092994046<br/> |
| log(Numeric numeric1 [, Numeric numeric2])<br/> | - Return the natural logarithm of 'numeric1' when called with one argument;<br/>- Return the logarithm of 'numeric2' to the base 'numeric1' when called with two arguments.<br/> | log(1) = 0.0<br/>log(2,8) = 3.0<br/> |
| log10(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the base 10 logarithm of 'numeric'.<br/> | log10(1000) = 3.0<br/> |
| log2(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the base 2 logarithm of 'numeric'.<br/> | log2(32) = 5<br/> |
| min_scale(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return minimum scale (number of fractional decimal digits) needed to represent the supplied value precisely.<br/> | min_scale(3.1415000000000) = 4<br/> |
| mod(Numeric numeric1, Numeric numeric2)<br/> | - Return "" if any parameter is null;<br/>- Return the remainder of 'numeric1' divided by 'numeric2'.<br/> | mod(3,2) = 1<br/>mod(-3.1415926,100) = -3.1415926<br/> |
| num_nonnulls([Expr expr1, Expr expr2, ...])<br/> | - Return the number of non-null arguments.<br/> | num_nonnulls(5, 3, null, null) = 2<br/> |
| num_nulls([Expr expr1, Expr expr2, ...])<br/> | - Return the number of null arguments.<br/> | num_nulls(5, null, null, null) = 3<br/> |
| pi()<br/> | - Return the mathematical constant PI.<br/> | pi() = 3.141592653589793<br/> |
| power(Numeric numeric1, Numeric numeric2)<br/> | - Return "" if any parameter is NULL.<br/>- Return 'numeric1'.power('numeric2').<br/> | power(4,0.5) = 2.0<br/> |
| radians(Numeric x)<br/> | - Return "" if 'x' is NULL;<br/>- Return radians of 'x', Convert degrees to radians.<br/> | radians(18.97) = 0.33108895910332425<br/> |
| radix_convert(Numeric numeric)<br/> | - Return "" if any of its arguments are NULL;<br/>- Return the result of converting 'numeric' from 'from_base' to 'to_base'.<br/>Note: abs(base) between [2,36].'from_base' is a negative number, 'numeric' is regarded as a signed number. Otherwise, 'numeric' is treated as unsigned. This function works with 64-bit precision.<br/> | radix_convert('6E',18,8) = 172<br/> |
| rand(Integer seed)<br/> | - Return a pseudo-random double precision value in the range [0.0, 1.0) if seed is NULL;<br/>- Return a pseudo-random double precision value in the range [0.0, 1.0) with an initial 'seed' of Integer.<br/> | rand(1)<br/>rand()<br/> |
| rand_integer(Integer INT1, [Integer INT2])<br/> | - Return a pseudorandom integer value in the range [0, 'INT1') if 'INT2' is NULL;<br/>- Return a pseudorandom integer value in the range [0, 'INT1') with an initial seed 'INT2'.<br/>Note: Two RAND_INTEGER functions will return idential sequences of numbers if they have the same initial seed and bound.<br/> | rand_integer(10)<br/>rand_integer(88, 89)<br/> |
| round(String str)<br/> | - Return "" if 'x' is NULL;<br/>- Return the nearest integer to 'x', with optional parameter 'y' indicating the number of decimal places to be rounded.<br/> | round(3.5) = 4<br/>round(3.14159265358979323846,10) = 3.1415926536<br/> |
| scale(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return scale of the argument (the number of decimal digits in the fractional part).<br/> | scale(3.1415000000000) = 13<br/> |
| sign(Numeric x)<br/> | - Return "" if 'x' is NULL;<br/>- Return -1 if 'x' is a negative number;<br/>- Return 0 if 'x' is equal to 0;<br/>- Return 1 if 'x' is a positive number.<br/> | sign(-3.5) = -1<br/> |
| sin(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the sine of 'numeric'.<br/> | sin(0) = 0.0<br/> |
| sind(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the sine of 'numeric' in units of degrees.<br/> | sind(15) = 0.25881904510252074<br/> |
| sinh(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the hyperbolic sine of 'numeric'.<br/> | sinh(1) = 1.1752011936438014<br/> |
| sqrt(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the square root of 'numeric'.<br/> | sqrt(9) = 3.0<br/> |
| tan(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the tangent of 'numeric'.<br/> | tan(1) = 1.5574077246549023<br/> |
| tand(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the tangent of 'numeric' in units of degrees.<br/> | tand(15) = 0.2679491924311227<br/> |
| tanh(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the hyperbolic tangent of 'numeric'.<br/> | tanh(1) = 0.7615941559557649<br/> |
| trim_scale(Numeric numeric)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return the result of reducing the proportion of values (decimal places) by removing trailing zeros.<br/> | trim_scale(3.1415000000000) = 3.1415<br/> |
| truncate(Numeric numeric, Integer cnt)<br/>trunc(Numeric numeric, Integer cnt)<br/> | - Return "" if any parameter is NULL;<br/>- Return the result of truncating 'numeric' values to 'cnt' decimal places.<br/> | truncate(42.324, 2) = 42.32<br/>trunc(42.324, -1) = 40<br/> |
# Collection
| Function | Description | Example |
| ------ | ------ | ------ |
| array(String value1 [,String value2, ....])<br/> | - Return an array created from a list of values ('value1', 'value2', ....).<br/> | array('he',7,'xxd') = [he, 7, xxd]<br/>array(array('he',5),'xxd') = return [[he, 5], xxd]<br/>array(array('he',5),array('','')) = return [[he, 5], [, ]]<br/> |
| array_append(Array array, Object element)<br/> | - Return "" if either argument is NULL;<br/>- Return the result of appends an element to the end of the 'array'.<br/> | array_append(array('he',7,'xxd'), 'cloud') = [he, 7, xxd, cloud]<br/> |
| array_concat([Array array1, Array array2, ...])<br/> | - Return "" if any input array is NULL;<br/>- Return an array that is the result of concatenating at least one array.<br/> | array_concat(array('he',7),array('xxd', 'cloud')) = [he, 7, xxd, cloud]<br/> |
| array_contains(Array array, Object needle)<br/> | - Return "" if 'array' is NULL;<br/>- Return whether the given element exists in 'array'.<br/>Note: Checking for null elements in the array is supported.<br/> | array_contains(array('he',7,'xxd'), 'cloud') = false<br/>array_contains(array('he',-1,''),'') = true<br/> |
| array_distinct(Array array)<br/> | - Return "" if 'array' is NULL;<br/>- Return an array with unique elements.<br/> | array_distinct(array('he',-1,'he')) = [he, -1]<br/> |
| array_except(Array array1, Array array2)<br/> | - Return "" if any parameter is null;<br/>- Return an ARRAY that contains the elements from 'array1' that are not in 'array2', without duplicates;<br/>- Return an empty ARRAY if no elements remain after excluding the elements in 'array2' from 'array1'.<br/> | array_except(array('he',7,'xxd'),array('he')) = [7, xxd]<br/>array_except(array('he',7,'xxd'),array('cloud')) = [he, 7, xxd]<br/> |
| array_intersect(Array array1, Array array2)<br/> | - Return "" if any parameter is null;<br/>- Return an ARRAY that contains the elements from 'array1' that are not in 'array2', without duplicates;<br/>- Return an empty ARRAY if no elements remain after excluding the elements in 'array2' from 'array1'.<br/> | array_intersect(array('he',7,'xxd'),array('he')) = [he]<br/>array_intersect(array('he',7,'xxd'),array('cloud')) = []<br/> |
| array_join(Array array, String delimiter[, String nullReplacement])<br/> | - Return "" if any parameter is null;<br/>- Return a string indicating that the elements in the given 'array' are concatenated using a 'delimiter', and empty array elements are filled with 'nullReplacement'.<br/>- Note: If nullReplacement is not specified, null elements in the array will be omitted from the resulting string.<br/> | array_join(array('he',7,'xxd'),'~') = he~7~xxd<br/>array_join(array('he',3,''),'~','oo') = he~3~oo<br/> |
| array_max(Array array)<br/> | - Return "" if any parameter is null;<br/>- Return the maximum value from the 'array'.<br/> | array_max(array(4,3,56)) = 56<br/> |
| array_min(Array array)<br/> | - Return "" if any parameter is null;<br/>- Return the minimum value from the 'array'.<br/> | array_min(array(4,3,56)) = 3<br/> |
| array_position(Array array,Object element)<br/> | - Return "" if any parameter is null;<br/>- Return the position of the first occurrence of 'element' in the given 'array' as int (starts from 1);<br/>- Return 0 if the given value could not be found in the 'array'.<br/> | array_position(array('he',7,'xxd'),'he') = 1<br/>array_position(array('he',7,''),'_') = 0<br/> |
| array_prepend(Array array,Object element)<br/> | - Return "" if 'array' is null;<br/>- Return the result of appending an element to the beginning of the array.<br/> | array_prepend(array(4,3),3) = [3, 4, 3]<br/> |
| array_remove(Array array,Object element)<br/> | - Return "" if 'array' is null;<br/>- Return the result of removing all elements that equal to 'element' from 'array'.<br/> | array_remove(array('he',7,'xxd'),'he') = [7, xxd]<br/> |
| array_reverse(Array array)<br/> | - Return "" if 'array' is null;<br/>- Return an array in reverse order.<br/> | array_reverse(array('he',7,'xxd')) = [xxd, 7, he]<br/> |
| array_slice(Array array, Integer start_offset[, Integer end_offset])<br/> | - Return "" if 'array' or 'start_offset' is null;<br/>- Return a subarray of the input 'array' between 'start_offset' and 'end_offset' inclusive;<br/>- Return an empty array if 'start_offset' is after 'end_offset' or both are out of 'array' bounds.<br/>Note: If 'end_offset' is omitted then this offset is treated as the length of the 'array'. Positive values are counted from the beginning of the array while negative from the end.<br/> | array_slice(array('he',7,'xxd'),1,2) = ['he', 7]<br/>array_slice(array('he','xxd','b'),-2,-1) = [3, 'xxd']<br/> |
| array_sort(Array array[,Boolean ascending_order[,Boolean null_first]])<br/> | - Return "" if 'array' is null;<br/>- Return the array in sorted order.<br/>Note: The function sorts an array, defaulting to ascending order with NULLs at the start when only the array is input. Specifying 'ascending_order' as true orders the array in ascending with NULLs first, and setting it to false orders it in descending with NULLs last. Independently, 'null_first' as true moves NULLs to the beginning, and as false to the end, irrespective of the sorting order.<br/> | array_sort(array('he',7,'xxd')) = [7, he, xxd]<br/>array_sort(array(3,7,5)) = [3, 5, 7]<br/>array_sort(array(,3,7),false,false) = [7, 3, ]<br/>array_sort(array(3,7,),true,false) = [3, 7, ]<br/> |
| array_union(Array array1[, Array array2, ...])<br/> | - Return "" if any input array is NULL;<br/>- Return an array that is the result of concatenating at least one array.<br/> | array_concat(array('he',7),array('xxd', 'cloud')) = [he, 7, xxd, cloud]<br/> |
| cardinality(Object input)<br/> | - Return "" if the input is NULL;<br/>- Return the number of elements in array if the input is array;<br/>- Return the number of entries in map if the input is map.<br/> | cardinality(array('he',7,'xxd')) = 3<br/>cardinality(map('he',7,'xxd',3)) = 2<br/> |
| element(Array array)<br/> | - Return "" if 'array' is empty or NULL;<br/>- Return the sole element of 'array' (whose cardinality should be one).<br/>Note: Throws an exception if array has more than one element.<br/> | element(array('he')) = he<br/> |
| find_in_set(String str,String strList)<br/> | - Return "" if either argument is NULL;<br/>- Return 0 if 'str' is not in 'strList' or if 'strList' is the empty string;<br/>- Return a value in the range of 1 to N if the string 'str' is in the string list 'strList' consisting of N substrings.<br/>Note: strList is a string composed of substrings separated by ',' characters. This function does not work properly if the first argument contains a comma (,) character.<br/> | FIND_IN_SET('b','a,b,b,c,d') = 2<br/>FIND_IN_SET('','a,,b,c,d') = 2<br/> |
| map([String value1, String value2, ...])<br/> | - Return "" if the number of parameters is not even;<br/>- Return a map created from a list of key-value pairs ((value1, value2), ... ).<br/> | Map('he',7,'xxd') = null<br/>Map('he',1,'xxd','cloud') = {he=1, xxd=cloud}<br/>Map('xxd','cloud',map(1,2),map(3,'apple')) = {xxd=cloud, {1=2}={3=apple}}<br/> |
| map_entries(Map map)<br/> | - Return "" if 'map' is NULL;<br/>- Return an array of all entries in the given 'map'.<br/> | map_entries(Map('he',1,'xxd','cloud')) = [he=1, xxd=cloud]<br/>map_entries(Map(1,2,'cloud','xxd')) = [xxd=cloud, 1=2]<br/> |
| map_from_arrays(Array array_of_keys, Array array_of_values)<br/> | - Return "" if any parameter is NULL;<br/>- Return a map created from an arrays of keys and values.<br/> | map_from_arrays(array('he', 'xxd'),array(1, 3)) = {he=1, xxd=3}<br/>map_from_arrays(array('xxd', array('cloud')),array(1, array(2))) = {1=xxd, [2]=[cloud]}<br/> |
| map_keys(Map map)<br/> | - Return "" if 'map' is NULL;<br/>- Return the keys of the 'map' as array. No order guaranteed.<br/> | map_keys(Map('he',1,'xxd','cloud')) = [he, xxd]<br/>map_keys(Map('xxd','cloud',map(1,2),map(3,'apple'))) = [xxd, {1=2}]<br/> |
| map_union([Map map1, Map map2, ...])<br/> | - Return "" if any of maps is null;<br/>- Return a map created by merging at least one map.These maps should have a common map type, the following map will overwrite the previous one.<br/> | map_union(map('he', 1),map('xxd', 3)) = {he=1, xxd=3}<br/>map_union(map('he', 1),map('he', 3)) = {he=3}<br/> |
| map_values(Map map)<br/> | - Return "" if 'map' is null;<br/>- Return the values of the 'map' as array. No order guaranteed.<br/> | map_values(Map('he',1,'xxd','cloud')) = [1, cloud]<br/>map_values(Map('xxd','cloud',map(1,2),map(3,'apple'))) = [cloud, {3=apple}]<br/> |
# Compression
| Function | Description | Example |
| ------ | ------ | ------ |
| compress(String string_to_compress [, String compress_type])<br/> | - Return "" if 'string_to_compress' is NULL;<br/>- Return "" if 'string_to_compress' is "";<br/>- Return the result as a binary string.<br/>Note: This function supports three compression algorithms: deflater, gzip, and zip. 'compress_type' defaults to defer. In addition, in order to output the compressed results in the form of strings, this method uses the ISO_8859_1 character set.<br/> | length(compress(replicate(string1,100)),'ISO_8859_1') = 33<br/>length(compress(''),'ISO_8859_1') = 0<br/> |
| uncompress(String string_to_uncompress, String compress_type)<br/> | - Return "" if 'string_to_uncompress' is NULL;<br/>- Return "" if 'string_to_uncompress' is "";<br/>- Return the result as a string.<br/>Note: This function supports three compression algorithms: deflater, gzip and zip. 'compress_type' defaults to defer.<br/> | uncompress(compress('inlong')) = "inlong"<br/> |
# Condition
| Function | Description | Example |
| ------ | ------ | ------ |
| coalesce(String value1 [, String value2, ...])<br/> | - Return "" If all arguments are NULL or "";<br/>- Return the first argument that is not NULL or "".<br/>Note: The return type is the least restrictive, common type of all of its arguments. The return type is nullable if all arguments are nullable as well.<br/> | coalesce('', 'SQL', 'hh') = "SQL"<br/> |
| if(Expr expr1,Expr expr2,Expr expr3)<br/> | - Return 'expr2' if 'expr1' returns true;<br/>- Return 'expr3' otherwise.<br/> | if(1 = 1,true,false) = true<br/> |
| ifnull(Expr expr1,Expr expr2)<br/>if_null(Expr expr1,Expr expr2)<br/> | - Return 'expr1' if 'expr1' returns not NULL;<br/>- Return 'expr2' otherwise.<br/> | ifnull(null, 3) = 3<br/>ifnull(6,'YES') = 6<br/> |
| isnull(Expr expr)<br/> | - Return true if 'expr' is NULL;<br/>- Return false otherwise.<br/> | isnull(5 + 3) = false<br/>isnull(5 / 0) = true<br/> |
| nullif(Expr expr1, Expr expr2)<br/>null_if(Expr expr1, Expr expr2)<br/> | - Return "" if 'expr1' = 'expr2' is true;<br/>- Return 'expr1' otherwise.<br/> | nullif(5, 3) = 5<br/> |
# Encryption
| Function | Description | Example |
| ------ | ------ | ------ |
| dayu_decrypt<br/> |  |  |
| decode(Binary binary,String charsetStr)<br/> | - Return "" if any parameter is NULL;<br/>- Return the result of encoding 'binary' using the character set specified by 'charsetStr'.<br/>Note: 'charsetStr' is one of ('US-ASCII', 'ISO-8859-1', 'UTF-8', 'UTF-16BE', 'UTF-16LE', 'UTF-16').<br/> | decode(encode('Hello','UTF-8'),'UTF-8') = "Hello"<br/> |
| encode(String strInfo,String charsetStr)<br/> | - Return "" if any parameter is NULL;<br/>- Return the result of encoding 'strInfo' using the character set specified by 'charsetStr'.<br/>- Note: 'charsetStr' is one of ('US-ASCII', 'ISO-8859-1', 'UTF-8', 'UTF-16BE', 'UTF-16LE', 'UTF-16').<br/> | decode(encode('Hello','UTF-8'),'UTF-8') = "Hello"<br/> |
| from_base64(String base64Str)<br/> | - Return "" if 'base64Str' is NULL;<br/>- Return the base64-decoded result from 'base64Str'.<br/> | from_base64('QXBhY2hlIEluTG9uZw==') = "Apache InLong"<br/> |
| md5(String string)<br/> | - Return "" if the 'string' is NULL;<br/>- Return the MD5 hash value of 'string' in the form of a 32-bit hexadecimal digit string.<br/> | md5("") = "d41d8cd98f00b204e9800998ecf8427e"<br/>md5("1") = "c4ca4238a0b923820dcc509a6f75849b"<br/> |
| sha(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return a string of 40 hexadecimal digits (the SHA-1 160 bit).<br/> | sha("5") = "ac3478d69a3c81fa62e60f5c3696165a4e5e6ac4"<br/> |
| sha2(String str, Integer hash_length)<br/> | - Return "" if either argument is NULL or the 'hash_length' is not one of (224,256,384,512);<br/>- Return scale of the argument (the number of decimal digits in the fractional part).<br/> | sha2("5",224) = "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"<br/> |
| to_base64(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the base64-encoded result from 'str'.<br/> | to_base64('app-fun') = "YXBwLWZ1bg=="<br/> |
# Json
| Function | Description | Example |
| ------ | ------ | ------ |
| json_array_append(String json_doc, String path1, String val1[,String path2, String val2, ...])<br/> | - Return "" if any argument is NULL;<br/>- Return the result of appends values to the end of the indicated arrays within a JSON document.<br/> | json_array_append(["a", ["b", "c"], "d"],$[0],2,$[1],3) = [["a","2"],["b","c","3"],"d"]<br/> |
| json_array_insert(String json_doc, String path1, String val1[, String path2, String val2, ...] )<br/> | - Return "" if any argument is NULL;<br/>- Return the 'json_doc' inserted into the array.<br/>Note: If multiple groups of parameters are passed in, the parameter subscripts of the latter groups need to be based on the document subscripts after the previous group of parameters are updated.<br/> | json_array_append(["a", {"b": [1, 2]}, [3, 4]], $[1], x) = ["a","x",{"b":[1,2]},[3,4]]<br/> |
| json_arrays([String value1, String value2, ...])<br/> | - Return a JSON array string constructed from a list of values.<br/> | JSON_ARRAYS() = []<br/>JSON_ARRAYS(1, '2') = [1,"2"]<br/>JSON_ARRAYS(JSON_ARRAY(1)) = [[1]]<br/> |
| json_exists(String json_doc, String path)<br/> | - Return true if 'json_doc' satisfies a given 'path' search criterion;<br/>- Return false otherwise.<br/> | JSON_EXISTS('{"a": true}', '$.a') = true<br/>JSON_EXISTS('{"a": true}', '$.b') = false<br/>JSON_EXISTS('{"a": [{ "b": 1 }]}', '$.a[0].b') = true<br/> |
| json_insert(String json_doc, String path1, String val1[, String path2, String val2, ...] )<br/> | - Return "" if any argument is NULL or the 'json_doc' argument is not a valid JSON document or any path argument is not a valid path expression or contains a * or ** wildcard.;<br/>- Return the result of inserting data into 'json_doc'.<br/> | json_insert({"a": {"b": [1, 2]}, "c": [3, 4]}, $.c[1][1], "2", "$.c[1][1][5]", "1") = {"a":{"b":[1,2]},"c":[3,[4,["2","1"]]]}<br/> |
| json_query(String json_doc, String path)<br/> | - Return "" if any parameter is NULL;<br/>- Return the string parsed from the 'path' in 'json_doc'.<br/> | json_query({\"people\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]}, $.people) = [{"name":"Alice"},{"name":"Bob"}]<br/>json_query({\"list\": [null, {\"name\": \"John\"}]}, $.list[1].name) = John<br/> |
| json_quote(String data)<br/>json_string(String data)<br/> | - Return "" if data is NULL;<br/>- Return a valid JSON string converted from a string (JSON_QUOTE) or any type of data (JSON_STRING).<br/>Note: JSON_QUOTE will escape interior quote and special characters (’"’, ‘', ‘/’, ‘b’, ‘f’, ’n’, ‘r’, ’t’)<br/> | json_quote('Column1\tColumn2) = \"Column1\\tColumn2\"<br/>json_string(true) = "true"<br/> |
| json_remove(String json_doc, String path1[, String path2, ...])<br/> | - Return "" if any argument is NULL or the 'json_doc' argument is not a valid JSON document or any path argument is not a valid path expression or is $ or contains a * or ** wildcard;<br/>- Return the result of removing data from 'json_doc'.<br/> | json_remove("{\"name\":\"Charlie\",\"hobbies\":[[\"swimming1\",\"swimming2\"], \"reading\",\"coding\"]}","$.age") = {"hobbies":[["swimming2"],"coding"],"name":"Charlie"}<br/> |
| json_replace(String json_doc, String path1, String val1[, String path2, String val2, ...] )<br/> | - Return "" if any argument is NULL or the 'json_doc' argument is not a valid JSON document or any path argument is not a valid path expression or contains a * or ** wildcard;<br/>- Return the result of replacing existing values in 'json_doc'.<br/> | json_replace("{ \"a\": 1, \"b\": [2, 3]}", "$.a", 10, "$.c", "[true, false]") = {"a": 10, "b": [2, 3]}<br/> |
| json_set(String json_doc, String path1, String val1[, String path2, String val2, ...] )<br/> | - Return "" if any argument is NULL or the 'json_doc' argument is not a valid JSON document or any path argument is not a valid path expression or contains a * or ** wildcard;<br/>- Return the result of inserting or updating data in 'json_doc'.<br/> | json_set({\"name\":\"Alice\"},"$.name","inlong") = {"name":"inlong"}<br/> |
| json_unquote(String data)<br/> | - Return "" if data is NULL;<br/>- Return the 'data' unmodified if the value does not start and end with double quotes or if it starts and ends with double quotes but is not a valid JSON string literal.<br/>Note: JSON_UNQUOTE will unescapes escaped special characters ('"', '', '/', 'b', 'f', 'n', 'r', 't')<br/> | json_unquote('Hello, World!') = "Hello, World!"<br/>json_unquote('Complex string with / and \\') = "Complex string with / and \\"<br/> |
| json_value(String json_doc,String path)<br/> | - Return "" if any parameter is NULL;<br/>- Return the scalar extracted from JSON string ('json_doc') based on 'path'.<br/> | json_value({"a": 1}, $.a) = 1<br/>json_value({\"person\": {\"name\": \"Alice\" ,\"age\": 30}}, $.person.name) = Alice<br/> |
# String
| Function | Description | Example |
| ------ | ------ | ------ |
| ascii(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the numeric value of the first character of 'str'.<br/> | ascii('abc') = 97<br/>ascii('A') = 65<br/>ascii(null) = ""<br/> |
| bit_length(String str,[String charset])<br/> | - Return "" if the 'str' is NULL;<br/>- Return number of bits in 'str'.<br/>Note: Charset is aligned with the JVM by default.<br/> | bit_length("hello world") = 88<br/>bit_length("hello 你好","utf-8") = 96<br/> |
| char_length(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the character length of 'str'.<br/> | char_length('hello world') = 11<br/>case2: char_length('应龙') = 2<br/> |
| concat(String string1 [, String string2, ...])<br/> | - Return NULL If any parameter is NULL;<br/>- Return the string of the connection ('string1', 'string2',...).<br/> | CONCAT("AA", "BB", "CC") = "AABBCC"<br/> |
| concat_ws(String string1 [, String string2, ...])<br/> | - Return NULL If 'STRING1' is NULL;<br/>- Return a string that concatenates ('STRING2', 'STRING3', ...) with a separator STRING1.<br/> | concat_ws('-', 'apple', 'banana', 'cloud') = "apple-banana-cloud"<br/>concat_ws('-', 'apple', '', 'cloud') = "apple--cloud"<br/>concat_ws('-', 'apple', null, 'cloud') = "apple-cloud"<br/> |
| contains(String leftStr , String rightStr)<br/> | - Return "" if 'leftStr' or rightStr is NULL;<br/>- Return True if 'rightStr' is found inside 'leftStr';<br/>- Return False otherwise.<br/> | contains('Transform SQL', 'SQL') = true<br/> |
| elt(Integer index, Expr expr1[, Expr expr2, ...])<br/> | - Return "" if 'index' is NULL or out of range;<br/>- Return the index-th('index' starts from 1) expression.<br/> | elt(2, 'a', 'b', 'c') = "b"<br/> |
| endswith(String s1, String s2)<br/> | - Return "" if either argument is NULL;<br/>- Return whether 's2' ends with 's2'.<br/> | endswith('Apache InLong', 'Long') = true<br/> |
| format(Numeric X,Integer D)<br/> | - Return "" if 'X' or 'D' is NULL;<br/>- Return the result of formatting the number 'X' to "#,###,###.##" format, rounded to 'D' decimal places.<br/> | FORMAT(12332.123456, 4) = "12,332.1235"<br/>FORMAT(12332.2,0) = "12,332"<br/> |
| initcap(String s1, String s2)<br/>init_cap(String s1, String s2)<br/> | - Return "" if 'str' is NULL;<br/>- Return a new form of 'str' with the first character of each word converted to uppercase and the rest characters to lowercase.<br/> | initcap('hello world') = "Hello world"<br/> |
| insert(String str,Integer pos,Integer len,String newStr)<br/> | - Return "" If any parameter is NULL;<br/>- Return the result of replacing the substring of length len with 'newStr' starting from the given position 'pos' in 'str'.<br/>Note: If the position is out of the string's bounds, the original string is returned.If the length exceeds the remaining length of the string from the given position, the replacement continues to the end of the string. If any argument is null, the function returns null.<br/> | INSERT('12345678', 3, 4, 'word') = '12word78'<br/>INSERT('12345678', -1, 4, 'word') = '12345678'<br/>INSERT('12345678', 3, 100, 'word') = '12word'<br/> |
| is_alpha(String str)<br/> | - Return "" If 'str' is NULL;<br/>- Return true if all characters in 'str' are letter;<br/>- Return false otherwise (Including cases where string is null and '').<br/> | is_alpha('inlong') = true<br/>is_alpha('inlong~') = false<br/> |
| is_decimal(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return true if 'str' can be parsed to a valid numeric;<br/>- Return false otherwise (Including cases where string is null and '').<br/> | is_decimal('3he') = false<br/>is_decimal('3.5') = true<br/> |
| is_digit(String str)<br/> | - Return "" If 'str' is NULL;<br/>- Return true if all characters in 'str' are digit;<br/>- Return false otherwise (Including cases where 'str' is null and '').<br/> | is_digit('3.5') = false<br/> |
| left(String str, Integer len)<br/> | - Return "" if any parameter is NULL;<br/>- Return "" if 'len' is less than or equal to zero;<br/>- Return a substring of len starting from the right side of the 'str'.<br/> | left('hello world',100) = "hello world"<br/>left('hello world',-15) = ""<br/> |
| length(String str, String charset)<br/> | - Return "" if 'str' is NULL;<br/>- Return the byte length of the 'str'.<br/>Note: charset defaults to matching with JVM.<br/> | length(应龙, utf-8) = 6<br/>length('hello world') = 11<br/> |
| locate(String str1, String str2, Integer pos)<br/>instr(String str1, String str2, Integer pos)<br/> | - Return "" if any of arguments is NULL'<br/>- Return 0 if not found'<br/>- Return the position of the first occurrence of 'str1' in 'str2' after position 'pos'.<br/> | locate('app', 'apple') = 1<br/>locate('app', 'appapp', 2) = 4<br/> |
| lower(String str)<br/>lcase(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the string obtained by converting all letters of 'str' to lowercase letters.<br/> | lower("ApPlE") = "apple"<br/> |
| lpad(String str1, Integer len, String str2)<br/> | - Return null if any of the three parameters is null or 'len' is less than 0;<br/>- Return the substring of 'str1' with subscripts in the range of [0, 'len') if 'len' is less than or equal to the length of 'str1';<br/>- Return "" if 'len' is longer than the length of 'str1' and 'str2' is "";<br/>- Return the filled string if 'str2' is not "".<br/> | lpad('he',7,'xxd') = "xxdxxhe"<br/>lpad('he',1,'') = "h"<br/> |
| ltrim(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the string 'str' without leading spaces.<br/> | ltrim(' in long ') = "in long "<br/> |
| parse_url(String urlStr, String keyword[, String parameter])<br/> | - Return NULL any required parameter is NULL;<br/>- Return the specified part from the 'urlStr'. Valid values for 'keyword'.<br/>Note: The 'keyword' is one of ('HOST', 'PATH', 'QUERY', 'REF', 'PROTOCOL', 'AUTHORITY', 'FILE', 'USERINFO'). Also a value of a particular key in QUERY can be extracted by providing the key as the third argument.<br/> | parse_url('http://inlong.apache.org/p.php?k1=v1&k2=v2#Ref1', 'QUERY', 'k1') = v1<br/>parse_url('http://inlong.apache.org/p.php?k1=v1&k2=v2#Ref1', 'PROTOCOL') = http<br/>parse_url('k1=v1&k2=v2', 'QUERY','k2') = v2<br/> |
| printf(String strfmt [, Object obj, ...])<br/> | - Return a formatted string from printf-style format strings.<br/> | printf("User %s has %d points and a balance of %.2f.", "Bob", 1500, 99.99) = " User Bob has 1500 points and a balance of 99.99."<br/> |
| regex(String str, String regexp)<br/>similar(String str, String regexp)<br/>regexp_like(String str, String regexp)<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return TRUE if any (possibly empty) substring of 'str' matches the Java regular expression 'regexp'.<br/> | regexp("The quick brown fox", "quick") = true<br/>regexp("The quick brown fox", "cold") = false<br/> |
| regex_substr(String source_string, String regexp)<br/> | - Return "" if any of the arguments are NULL or regexp if invalid or pattern is not found;<br/>- Return the first substring in 'str' that matches 'regexp'.<br/> | regex_substr("abc123def", "(\\d+)") = 123<br/> |
| regexp_count(Integer INT1, [Integer INT2])<br/> | - Return "" if any of the arguments are NULL or 'regexp' is invalid;<br/>- Return the number of times 'str' matches the 'regexp' pattern.<br/>Note: 'regexp' must be a Java regular expression.<br/> | regexp_count("The quick brown fox quick", "quick") = 2<br/> |
| regexp_extract(String str, String regexp, [Integer extractIndex])<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return a string from 'str' which extracted with a specified regexp expression 'regexp' and a regexp match group index 'extractIndex'.<br/>Note: 'regexp' must be a Java regular expression. 'extractIndex' indicates which regexp group to extract and starts from 1, also the default value if not specified. 0 means matching the entire 'regexp' expression. In addition, the regexp match group index should not exceed the number of the defined groups.<br/> | REGEXP_EXTRACT("abc123def", "(\\d+)", 1) = 123<br/>REGEXP_EXTRACT("Name: John, Age: 25, Location: NY", "Name: (\\w+), Age: (\\d+), Location: (\\w+)", 2) = 25<br/>REGEXP_EXTRACT("abc123def", "(\\d+)", 2) = null<br/>REGEXP_EXTRACT("abc123def", "abcdef", 1) = null<br/> |
| regexp_extract_all(String str, String regexp, [Integer extractIndex])<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return an array consisting of all substrings from the 'str' that match the 'regexp' expression and correspond to the 'extractIndex' set of regular expressions.<br/>Note: 'regexp' must be a Java regular expression. 'extractIndex' indicates which regexp group to extract and starts from 1, also the default value if not specified. 0 means matching the entire 'regexp' expression.<br/> | REGEXP_EXTRACT_ALL("abc123def456ghi789", "(\\d+)", 0) = [123, 456, 789]<br/>REGEXP_EXTRACT_ALL("Name: John, Age: 25, Location: NY", "Name: (\\w+), Age: (\\d+), Location: (\\w+)", 1) = [John]<br/>REGEXP_EXTRACT_ALL("Name: John, Age: 25, Location: NY", "Name: (\\w+), Age: (\\d+), Location: (\\w+)", 0) = [Name: John, Age: 25, Location: NY]<br/> |
| regexp_instr(String str, String regexp)<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return the position of the first substring in 'str' that matches 'regexp'.<br/> | regexp_instr("abc123def", "(\\d+)") = 4<br/> |
| regexp_matches(String source_string, String regexp [,String flags])<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return the result of the first match of the specified regular expression 'regexp' from 'source_string'. Note: 'flags' is one of  ('g' -> flag can be used when we want to match all the substrings that occur, 'i' -> flag to ignore case for matching, 'x' -> flag to extend syntax (ignoring whitespace and comments in regular expressions), 'm' and 'n' -> flag allows regular expressions to match across multiple lines)<br/> | regexp_matches("The quick brown fox", "quick") = [{"quick"}]<br/>regexp_matches("foo 123 bar 456", "\\d+", "g") = [{"123"},{"456"}]<br/> |
| regexp_replace(String source_string, String regexp, String replacement)<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return a string from 'source_string' with all the substrings that match a regular expression 'regexp' consecutively being replaced with 'replacement'.<br/> | regexp_replace('foobarbaz', 'b..', 'X') = "fooXbaz"<br/> |
| regexp_split_to_array(String source_string, String regexp, String flags)<br/> | - Return "" if any of the arguments are NULL or invalid;<br/>- Return a string from 'source_string' with all the substrings that match a regular expression 'regexp' consecutively being replaced with 'replacement'.<br/>Note: 'flags' is one of  ('g' -> flag can be used when we want to match all the substrings that occur, 'i' -> flag to ignore case for matching, 'x' -> flag to extend syntax (ignoring whitespace and comments in regular expressions), 'm' and 'n' -> flag allows regular expressions to match across multiple lines).<br/> | regexp_split_to_array("hello world","\s+") = {hello, world}<br/> |
| repeat(String str, Integer times)<br/>replicate(String str, Integer times)<br/> | - Return "" if any parameter is null;<br/>- Return a new string that repeats the 'str' by a certain number of 'times'.<br/> | repeat('apple', 2) = "appleapple"<br/> |
| replace(String s, String s1, String s2)<br/> | - Return "" if any parameter is null;<br/>- Return the result of replacing string 's1' with string 's2' in string 's'.<br/> | replace('Hello World', '', 'J') = "JHJeJlJlJoJ JWJoJrJlJdJ"<br/> |
| reverse(String str)<br/> | - Return "" if 'str' is a empty string or NULL;<br/>- Return the 'str' with the order of the characters reversed.<br/> | reverse('apple') = "elppa"<br/> |
| right(String str)<br/> | - Return "" if either 'str' or 'len' is NULL;<br/>- Return "" if it is less than or equal to zero;<br/>- Return a substring of 'len' starting from the right side of the 'str'.<br/> | right('hello world',100) = "hello world"<br/> |
| rpad(String str)<br/> | - Return "" if any of the three parameters is NULL or 'len' is less than 0;<br/>- Return the substring of 's1' with subscripts in the range of [0, 'len') if 'len' is less than or equal to the length of 's1';<br/>- Return "" if 's2' is "" and 'len' is longer than the length of 's1';<br/>- Return the result string of padding string 's2' at the end of string 's1' to make the length of the string 'len' if 's2' is not "".<br/> | rpad('he',1,'xxd') = "h"<br/>rpad('he',7,'') = ""<br/> |
| rtrim(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the string 'str' with trailing space characters removed.<br/> | rtrim(' in long ') = " in long"<br/> |
| soundex(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return a four character code representing the sound of 'str'.<br/> | soundex('hello world') = "H464"<br/> |
| space(Integer N)<br/> | - Return "" if 'N' is NULL or less than or equal to 0;<br/>- Return a string consisting of 'N' space characters.<br/> | space(5) = "     "<br/> |
| split_index(String str, String delimiter, Integer index)<br/>splitindex(String str, String delimiter, Integer index)<br/> | - Return "" if the index is negative or any of the arguments is NULL;<br/>- Return "" NULL if the index is out of bounds of the split strings;<br/>- Return the string at the given 'index' integer(zero-based) after splitting 'str' by 'delimiter'.<br/> | split_index('a,b,c', ',', 1) = "b"<br/> |
| startswith(String s1, String s2)<br/> | - Return "" if either argument is NULL;<br/>- Return whether 's2' starts with 's2'.<br/> | startswith('Apache InLong', 'A') = true<br/> |
| str_to_map(String s1, String pairDelimiter, String keyValueDelimiter)<br/> | - Return "" if 'str' is NULL;<br/>- Return a map after splitting the 'str' into key/value pairs using 'pairDelimiter'(default is ',') and 'keyValueDelimiter'(default is '=');<br/>Note: Both 'pairDelimiter' and 'keyValueDelimiter' are treated as regular expressions.So special characters(e.g. <([{^-=$!\|]})?*+.>) need to be properly escaped before using as a delimiter literally.<br/> | str_to_map('key1=value1,key2=value2,key3=value3') = {key1=value1, key2=value2, key3=value3}<br/>str_to_map("name->John!age->30!city->China" , "!" , "->") = {name=John, age=30, city=China}<br/> |
| strcmp(String s1, String s2)<br/> | - Return "" if either argument is NULL;<br/>- Return 0 if the strings are the same;<br/>- Return -1 if 's1' is smaller than 's2' according to the current sort order;<br/>- Return 1 otherwise.<br/> | strcmp('hello world','banana') = 1<br/> |
| substring(String s1, Integer pos, Integer len)<br/>substr(String s1, Integer pos, Integer len)<br/>mid(String s1, Integer pos, Integer len)<br/> | - Return "" if 'str' is NULL;<br/>- Return a substring of 'str' starting from position 'pos' with length 'len' (to the end by default).<br/>Note: This function also supports "substring(str FROM pos [ FOR len ])".<br/> | substring('apple', 1, 3) = "app"<br/> |
| substring_index(String str, String delim, Integer count)<br/> | - Return "" if any parameter is NULL;<br/>- Return everything to the left of the last count occurrences of 'delim' (counting from the left), if 'count' is positive;<br/>- Return everything to the right of the last count occurrences of 'delim' (counting from the right) if 'count' is negative.<br/> | SUBSTRING_INDEX('AA. ',' ',1) = "AA."<br/> |
| translate(String origin_string, String find_chars, String replace_chars)<br/> | - Return "" if any parameter is NULL;<br/>- Return the result of replacing all occurrences of both 'find_chars' and 'origin_string' with the characters in 'replace_chars'.<br/> | translate(apache@inlong.com, '@', '.') = "apache.inlong.com"<br/>translate(hello WorD, 'WD', 'wd') = "hello word"<br/> |
| trim(String str)<br/>btrim(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the result of deleting spaces before and after the 'str'.<br/> | trim(' in long ') = "in long"<br/> |
| unhex(String str)<br/> | - Return "" if 'str' is NULL;<br/>- Return the result of interpreting each pair of characters in the argument as the character corresponding to its hexadecimal number.<br/> | unhex("696E6C6F6E67") = "inlong"<br/> |
| upper(String s)<br/>ucase(String s)<br/> | - Return "" if 's' is NULL;<br/>- Return the result of converting 's' to uppercase<br/> | upper("ApPlE") = "APPLE"<br/> |
| url_decode(String str[, String charset])<br/> | - Return "" if 'str' is NULL, or there is an issue with the decoding process(such as encountering an illegal escape pattern), or the encoding scheme is not supported;<br/>- Return the result of decoding a given 'str' in 'application/x-www-form-urlencoded' format using the charset(default:UTF-8) encoding scheme.<br/> | url_decode('https%3A%2F%2Fapache.inlong.com%2Fsearch%3Fq%3Djava+url+encode') = "https://apache.inlong.com/search?q=java url encode"<br/>url_decode('https%3A%2F%2Fapache.inlong.com%2Fsearch%3Fq%3Djava+url+encode','UTF-8') = "https://apache.inlong.com/search?q=java url encode" |
| url_encode(String str[, String charset])<br/> | - Return "" if 'str' is NULL, or there is an issue with the decoding process(such as encountering an illegal escape pattern), or the encoding scheme is not supported;<br/>- Return the result of translating 'str' into 'application/x-www-form-urlencoded' format using the charset(default:UTF-8) encoding scheme.<br/> | url_encode('https://apache.inlong.com/search?q=java url encode') = "https%3A%2F%2Fapache.inlong.com%2Fsearch%3Fq%3Djava+url+encode"<br/>url_encode('https://apache.inlong.com/search?q=java url encode','UTF-8') = "https%3A%2F%2Fapache.inlong.com%2Fsearch%3Fq%3Djava+url+encode" |
| uuid(String s)<br/> | - Return a UUID (universally unique identifier) string based on RFC 4122 Type 4 (pseudo-randomly generated) UUID.<br/> | uuid()<br/> |
# Temporal
| Function | Description | Example |
| ------ | ------ | ------ |
| convert_tz(String leftStr , String rightStr)<br/> | - Return NULL if any parameter is NULL;<br/>- Return the result of converts a datetime 'string1' (with default ISO timestamp format yyyy-MM-dd HH:mm:ss’) from time zone 'string2' to time zone 'string3'.<br/>Note: The format of time zone should be  either an abbreviation such as “PST”, a full name such as “America/Los_Angeles”, or a custom ID such as “GMT-08:00”.<br/> | CONVERT_TZ('1970-01-01 00:00:00', 'UTC', 'America/Los_Angeles') = "1969-12-31 16:00:00"<br/> |
| date_add(String dateStr,String intervalExprStr)<br/> | - Return "" if 'dateStr' is NULL;<br/>- Return DATE if 'dateStr' is a DATE value and your calculations involve only YEAR, MONTH, and DAY parts(that is, no time parts);<br/>- Return TIME if 'dateStr' is a TIME value and the calculations involve only HOURS, MINUTES,and SECONDS parts (that is, no date parts);<br/>- Return DATETIME if the first argument is a DATETIME (or TIMESTAMP) value, or if the first argument is a DATE and the unit value uses HOURS, MINUTES, or SECONDS, or if the first argument is of type TIME and the unit value uses YEAR, MONTH, or DAY;<br/>- Return String otherwise (type VARCHAR).<br/>Note: Regarding intervalExpr, please refer to the MySQL official website.<br/> | date_add('2020-12-31 23:59:59',INTERVAL 999 DAY) = "2023-09-26 23:59:59"<br/>DATE_ADD('1992-12-31 23:59:59', INTERVAL '-1.999999' SECOND_MICROSECOND) = "1992-12-31 23:59:57.000001"<br/> |
| date_format(String timestampStr, String formatStr)<br/> | - Return "" if any parameter is NULL;<br/>- Return a string value that converts a timestamp (in seconds) to a date format string in the specified format.<br/>Note: The format string is compatible with Java’s SimpleDateFormat<br/> | date_format('2024-08-01 22:56:56', 'yyyy/MM/dd HH:mm:ss') = "2024/08/01 22:56:56"<br/> |
| date_sub(String dateStr,String intervalExprStr)<br/>datesub(String dateStr,String intervalExprStr)<br/> | - Return "" if 'dateStr' is NULL;<br/>- Return DATE if the date argument is a DATE value and your calculations involve only YEAR, MONTH, and DAY parts(that is, no time parts);<br/>- Return TIME if the date argument is a TIME value and the calculations involve only HOURS, MINUTES,and SECONDS parts (that is, no date parts);<br/>- Return DATETIME if the first argument is a DATETIME (or TIMESTAMP) value, or if the first argument is a DATE and the unit value uses HOURS, MINUTES, or SECONDS, or if the first argument is of type TIME and the unit value uses YEAR, MONTH, or DAY;<br/>- Return String otherwise (type VARCHAR).<br/>Note: Regarding 'intervalExpr', please refer to the MySQL official website.<br/> | DATE_SUB('1992-12-31 23:59:59', INTERVAL '-1.999999' SECOND_MICROSECOND) = "1993-01-01 00:00:00.999999"<br/> |
| datediff(String dateStr1, String dateStr2)<br/> | - Return "" if one of the two parameters is null or "";<br/>- Return "" if one of the two parameters has an incorrect date format;<br/>- Return the number of days between the dates 'dateStr1'->'dateStr2'.<br/> | datediff('2018-12-10 12:30:00', '2018-12-09 13:30:00') = 1<br/>datediff('2018-12', '2018-12-12') = ""<br/> |
| day_name(String dateStr)<br/>dayname(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the name of the day of the week from 'dateStr'.<br/> | dayname(2024-02-29) = THURSDAY<br/> |
| day_of_month(String dateStr)<br/>dayofmonth(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the day of a month (an integer between 1 and 31) from 'dateStr'.<br/> | dayofmonth(2024-02-29) = 29<br/> |
| day_of_week(String dateStr)<br/>dayofweek(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the day of a week (an integer between 1(Sunday) and 7(Saturday)) from 'dateStr'.<br/> | dayofweek(2024-02-29) = 5<br/> |
| day_of_year(String dateStr)<br/>dayofyear(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the day of a year (an integer between 1 and 366) from 'dateStr'.<br/> | dayofyear(2024-02-29) = 60<br/> |
| from_unix_time(Numeric numeric,String formatStr)<br/>form_unixtime(Numeric numeric,String formatStr)<br/> | - Return "" if 'numeric' is NULL;<br/>- Return a representation of the numeric argument as a value in string.<br/>Note: 'formatStr' defaults to 'yyyy-MM-dd HH:mm:ss'. numeric is an internal timestamp value representing seconds since ‘1970-01-01 00:00:00’ UTC, such as produced by the UNIX_TIMESTAMP() function.<br/> | from_unix_time(44) = "1970-01-01 08:00:44"<br/> |
| hour(String timestamp)<br/> | - Return "" if 'timestamp' is null;<br/>- Return the hour of a day (an integer between 0 and 23) from SQL 'timestamp'.<br/> | hour(2024-08-12 12:23:34) = 12<br/> |
| localdate([String timeZoneStr])<br/>currentdate([String timeZoneStr])<br/>current_date([String timeZoneStr])<br/>curdate([String timeZoneStr])<br/> | - Return the current date in the specified 'timeZoneStr'.<br/> | localDate("UTC") = currentDate<br/>localDate() = currentDate<br/> |
| localtime([String timeZoneStr])<br/>current_time([String timeZoneStr])<br/> | - Return the current time in the specified time zone.<br/> | localTime() = currentTime<br/>currentTime("UTC") = currentTime<br/> |
| minute(String timestamp)<br/> | - Return "" if 'timestamp' is null;<br/>- Return the minute of an hour (an integer between 0 and 59) from SQL 'timestamp'.<br/> | minute(2024-08-12 12:23:34) = 23<br/> |
| month(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the month of a year (an integer between 1 and 12) from 'dateStr'.<br/> | month(2024-08-08) = 8<br/> |
| now()<br/> | - Return the current SQL timestamp for the local time zone.<br/> | now()<br/> |
| quarter(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the quarter of a year (an integer between 1 and 4) from 'dateStr'.<br/> | quarter(2024-08-08) = 3<br/> |
| second(String timestamp)<br/> | - Return "" if 'timestamp' is null;<br/>- Return the second of a minute (an integer between 0 and 59) from SQL 'timestamp'.<br/> | second(2024-08-12 12:23:34) = 34<br/> |
| timediff(String dateStr1, String dateStr2)<br/>time_diff(String dateStr1, String dateStr2)<br/> | - Return "" if 'dateStr1' or 'dateStr2' is NULL and the conversion types of 'dateStr1' and 'dateStr2' are different;<br/>- Return 'dateStr1' - 'dateStr2' expressed as a time value.<br/>Note: 'dateStr1' and 'dateStr2' are strings converted to TIME or DATETIME expressions.<br/> | timediff('23:59:59.000001','01:01:01.000002') = "22:58:57.999998"<br/> |
| timestamp(String unit, String datetime_expr1, String datetime_expr2)<br/> | - Return "" if 'datetime_expr1' or 'datetime_expr2' is NULL;<br/>- Return the date or datetime expression expr as a datetime value if there is only one parameter;<br/>- Return the result of the date or date time expression 'datetime_expr1' plus the time expression 'datetime_expr2' if there are two parameters.<br/> | timestamp('2003-12-31 12:00:00.600000','12:00:00') = "2004-01-01 00:00:00.600000"<br/> |
| timestamp_add(String unit, Integer cnt, String baseDateStr)<br/>timestampadd(String unit, Integer cnt, String baseDateStr)<br/> | - Return "" if any parameter is null;<br/>- Return the result of adding the integer expression interval to the date or datetime expression 'baseDateStr'.<br/>Note: 'unit' is one of (MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR).<br/> | timestamp_add('MICROSECOND',3,'1970-01-01 00:00:44') = "1970-01-01 00:00:44.000003"<br/> |
| timestamp_diff(String unit, String datetime_expr1, String datetime_expr2)<br/>timestampdiff(String unit, String datetime_expr1, String datetime_expr2)<br/> | - Return "" if any parameter is null;<br/>- Return 'datetime_expr2' − 'datetime_expr1', where 'datetime_expr1' and 'datetime_expr2' are date or datetime expressions.<br/>Note: 'unit' is one of (MICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR).<br/> | timestampdiff('MONTH','2003-02-01','2003-05-01') = 3<br/> |
| to_date(String str [,String format])<br/> | - Return "" if 'str' is NULL;<br/>- Return the result of converting the date string 'str' to a date in the format 'format'(default is 'yyyy-MM-dd').<br/> | to_date('20240815', 'yyyyMMdd') = "2024-08-15"<br/> |
| to_timestamp(String str [,String format])<br/> | - Return "" if 'str' is NULL;<br/>- Return the result of converting the date and time string 'str' to the 'format' (by default: yyyy-MM-dd HH:mm:ss if not specified) under the 'UTC+0' time zone to a timestamp.<br/> | to_timestamp('1970/01/01 00:00:44', 'yyyy/MM/dd HH:mm:ss') = "1970-01-01 00:00:44.0"<br/> |
| unix_timestamp([String dateStr [, String format]])<br/> | - Return current Unix timestamp in seconds if no parameter is specified;<br/>- Return the result of converting the date and time string 'dateStr' to the format 'format' (by default: yyyy-MM-dd HH:mm:ss if not specified) to Unix timestamp (in seconds) if there is a parameter specified<br/> | unix_timestamp('1970/01/01 08:00:44', 'yyyy/MM/dd HH:mm:ss') = "1970/01/01 08:00:44"<br/> |
| week(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the week of a year (an integer between 1 and 53) from 'dateStr'.<br/> | week(2024-02-29) = 9<br/> |
| year(String dateStr)<br/> | - Return "" if 'dateStr' is null;<br/>- Return the year from SQL date.<br/> | year(2024-08-08) = 2024<br/> |
